<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <!-- <script>
        let sym01 = Symbol('foo');
        let obj = {
            getData(){
                return 'adsionli'
            },
            toString(){
                return 'adsionli'
            }
        }    
        let sym02 = Symbol(obj);   
        console.log(sym01)
        console.log(sym02)
        console.log(Boolean(sym01))
    </script>
    <script>
        const COLOR_RED = Symbol('red')
        const COLOR_GREEN = Symbol('green');
        console.log(COLOR_RED == COLOR_GREEN)
        function getComplement(color){
            switch (color) {
                case COLOR_RED:
                    return COLOR_GREEN
                case COLOR_GREEN:
                    return COLOR_RED
                default:
                    return "error"
            }
        }
        console.log(getComplement(COLOR_RED));
    </script> -->
    <script>
        // Array.prototype[Symbol.unscopables]
        // console.log(Object.keys(Array.prototype[Symbol.unscopables]))
        // class a1 extends Array {
        //     constructor(args) {
        //         super(args);
        //         this[Symbol.isConcatSpreadable] = false;
        //     }
        // }
        // let a = ['adsionli', 'shirley'];
        // let aa = new a1();
        // aa[0] = 'blog';
        // aa[1] = 'adsionli';
        // console.log(aa.concat(a))
    </script>
    <script>
        // let obj = {
        //     toString() {
        //         return "obj"
        //     }
        // }
        // let s1 = Symbol(obj);
        // console.log(s1);

        // let s1 = Symbol();
        // let s2 = Symbol();
        // console.log('no string param:', s1 == s2);
        // let s3 = Symbol('str');
        // let s4 = Symbol('str');
        // console.log('has string param:', s3 == s4);
        // let s5 = Symbol.for('for');
        // let s6 = Symbol.for('for');
        // console.log('Symbol for:', s5 == s6);

        // var sym = Symbol();
        // var a = {
        //     [sym]: 'welcome to adisonli blog!'
        // }
        // //这里的输出就是'welcome to adisonli blog!'
        // console.log(a[sym]);
    </script>
    <script>
        // let sym = Symbol('symbol');
        // let a = {
        //     sym: 'adsionli blog'
        // }
        // a[sym] = 'adsionli'
        // console.log('point:',a.sym);
        // console.log('sym Symbol:',a[sym].toString(), sym.toString());
        // console.log('iterator get:',a['sym']);
        // console.log('point == iterator:',a.sym == a['sym']);

        // let obj = {};
        // let a = Symbol('a');
        // let b = Symbol('b');

        // obj.name = "shirley";
        // obj.age = 25;
        // obj[a] = 'adsionli';
        // obj[b] = 'blog';
        // console.log(obj)
        // let s = Object.getOwnPropertyNames(obj);
        // console.log('string attributes:', ...s);
        // let ssym = Object.getOwnPropertySymbols(obj);
        // console.log('symbol attributes:', ...ssym);
        // for (let key in obj) {
        //     console.log("for...in...:", key);
        // }

        // var size = Symbol('size');
        // class Collection {
        //     constructor() {
        //         this[size] = 0;
        //     }

        //     add(item) {
        //         //这里可以通过获取this[size]的大小作为键名
        //         this[this[size]] = item;
        //         this[size]++;
        //     }

        //     static sizeOf(obj) {
        //         return obj[size];
        //     }
        // }

        // let x = new Collection();
        // console.log('x size:', Collection.sizeOf(x));
        // x.add('adisonli');
        // x.add('blog');
        // console.log('x size:', Collection.sizeOf(x));
        // console.log('x attributes:', Object.getOwnPropertyNames(x));
        // console.log('x all attributes:', Reflect.ownKeys(x));
    </script>
    <script>
        // var a = Symbol('a');
        // var b = Symbol('b');
        // var objS = {
        //     name: "adsionli love shirley"
        // };
        // objS[a] = 'adsionli';
        // objS[b] = 'blod';
        // console.log(Object.getOwnPropertySymbols(objS));
        // console.log(Reflect.ownKeys(objS));
        // console.log(objS[a], objS[b])
    </script>
    <script>
        // class JudgeEven {
        //     //这里就将对象的instanceof改成了传入对象是否是偶数
        //     static [Symbol.hasInstance](obj) {
        //         console.log(obj)
        //         return Number(obj) % 2 === 0;
        //     }
        // }
        // //使用上面的判断
        // console.log("judge even:", 1 instanceof JudgeEven);
        // console.log("judge even:", 2 instanceof JudgeEven);
        // console.log("judge even:", 2468 instanceof JudgeEven);
    </script>
    <script>
        // //第一种是普通的数组对象的设置这个默认内置属性
        // let arr = ['c', 'd'];
        // console.log('Symbol.isConcatSpreadable true:', ['a', 'b'].concat(arr, 'e'));
        // arr[Symbol.isConcatSpreadable] = false;
        // console.log('Symbol.isConcatSpreadable true:', ['a', 'b'].concat(arr, 'e'));
        // //第二种是在对象中使用本属性，这个就需要写成是实例中的一个属性
        // class A01 extends Array {
        //     constructor(args) {
        //         super(args);
        //         this[Symbol.isConcatSpreadable] = true;
        //     }
        // }
        // class A02 extends Array {
        //     constructor(args) {
        //         super(args);
        //         this[Symbol.isConcatSpreadable] = false;
        //     }
        // }
        // let a1 = new A01();
        // for (let i = 1; i <= 5; i++) {
        //     a1[i] = i;
        // }
        // let a2 = new A02();
        // for (let i = 1; i <= 5; i++) {
        //     a2[i] = i * 2;
        // }
        // console.log('a01 Symbol.isConcatSpreadable is true', a2.concat(a1));
        // console.log('a02 Symbol.isConcatSpreadable is false', a1.concat(a2));
        // //第三种是类数组对象的使用，也是可以赊着Symbol.isConcatSpreadable属性的
        // let obj = {
        //     length: 2,
        //     0: 'adsionli',
        //     1: 'blog'
        // }
        // obj[Symbol.isConcatSpreadable] = true;
        // let arr001 = ['shirley', 'wife'];
        // console.log('obj Symbol.isConcatSpreadable true', arr001.concat(obj));
        // obj[Symbol.isConcatSpreadable] = false;
        // console.log('obj Symbol.isConcatSpreadable false', arr001.concat(obj));
    </script>
    <script>
        // class AS01 extends Array {
        //     constructor(args) {
        //         super(args);
        //         this[Symbol.isConcatSpreadable] = false;
        //     }

        //     static get [Symbol.species]() {
        //         return Array;
        //     }
        // }
        // let as = new AS01(1, 2, 3, 4, 5, 6, 7, 8, 9);
        // let mapping = as.map(x => x * x);
        // console.log('as instanceof AS01:', as instanceof AS01);
        // console.log('as instanceof Array:', as instanceof Array);
        // console.log('mapping instanceof AS01:', mapping instanceof AS01);
        // console.log('mapping instanceof Array:', mapping instanceof Array);
        // let mmm = as;
        // console.log(mmm instanceof AS01)
    </script>
    <script>
        let obj = {
            [Symbol.toPrimitive](hint) {
                console.log('type:', hint)
                switch (hint) {
                    case 'number':
                        return 123;
                    case 'string':
                        return "str";
                    case 'default':
                        return 'default';
                    default:
                        throw new Error('no this type:' + hint);
                }
            }
        }
        console.log("number:", 2 * obj);
        console.log("default:", 3 + obj);
        console.log("default:", obj == 'default');
        console.log("string:", String(obj));
    </script>
</body>

</html>