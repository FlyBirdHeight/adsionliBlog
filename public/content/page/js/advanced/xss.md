# 前端安全-Xss

| 文档创建人 | 创建日期   | 文档内容     | 更新时间   |
| ---------- | ---------- | ------------ | ---------- |
| adsionli   | 2022-08-16 | 前端安全-Xss | 2022-08-16 |

## Xss

什么是 Xss，它是前端的一种攻击手段，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

XSS 的本质是：

_恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。_

由于 Xss 攻击能够直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。

在部分情况下，**由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略**。

通过哪种方法“注入”恶意脚本的呢？除了是业务上的“用户的 UGC 内容”可以进行注入，包括 URL 上的参数等都可以是攻击的来源。在处理输入时，以下内容都不可信：

1. 来自用户的 UGC 信息

2. 来自第三方的链接

3. URL 参数

4. POST 参数

5. Referer （可能来自不可信的来源）

6. Cookie （可能来自其他子域注入）

### Xss注入方法

- 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。
- 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。
- 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。
- 在标签的 href、src 等属性中，包含 `javascript:` 等可执行代码。
- 在 onload、onerror、onclick 等事件中，注入不受控制代码。
- 在 style 属性和标签中，包含类似 `background-image:url("javascript:...");` 的代码（新版本浏览器已经可以防范）。
- 在 style 属性和标签中，包含类似 `expression(...)` 的 CSS 表达式代码（新版本浏览器已经可以防范）。

### Xss 分类

Xss 攻击主要分为了三类：存储型、反射型、Dom 型

| 类型       | 存储区                  | 插入点          |
| ---------- | ----------------------- | --------------- |
| 存储型 XSS | 后端数据库              | HTML            |
| 反射型 XSS | URL                     | HTML            |
| DOM 型 XSS | 后端数据库/前端存储/URL | 前端 JavaScript |

> - 存储区：恶意代码存放的位置。
> - 插入点：由谁取得恶意代码，并插入到网页上。

#### 存储型Xss

**攻击步骤：**

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

**常见场景：**

带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

#### 反射型Xss

**攻击步骤：**

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型 XSS 跟存储型 XSS 的区别是：**存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。**

常见场景：

通过 URL 传递参数的功能，如网站搜索、跳转等。

> 由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。
>
> 比如我们常见的危险链接分享

#### Dom型Xss

**攻击步骤：**

1. 攻击者构造出特殊的URL，其中包含恶意代码
2. 用户打开带有恶意代码的URL
3. 用户浏览器接收到响应后解析之下，前端Js取出URL的恶意代码并执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

DOM 型 XSS 跟前两种 XSS 的区别：**DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞**

### Xss攻击预防

首先Xss攻击具有两大要素：

1. 攻击者提交恶意代码
2. 浏览器解析并执行恶意代码

然后就是针对这两大要素进行预防。

对于第一个要素的预防我们可以很自然的想到是否可以在用户输入的过程中，过滤掉用户输入的恶意代码呢？

#### 输入过滤

在用户提交时，由前端过滤输入，然后提交到后端。这样做是否可行呢？

答案是不可行。**攻击者能够绕过前端过滤，直接构造请求，就可以提交恶意代码了**。

那如果在后端写入数据库之前，对输入内容进行过滤，这样是否可行呢？

答案依然是不可行。

举一个例子，一个正常的用户输入了 `5 < 7` 这个内容，在写入数据库前，被转义，变成了 `5 &lt; 7`。

这里就存在一个问题，**我们并不知道，这段内容具体要输出到什么地方，因为这段数据可以被使用在浏览器上，也可以被使用在客户端中，如果我们在后端写入时，进行数据的转译后，当我们把数据输出到不同的地方的时候，可能会造成一部分场景下出现乱码的问题**。所以，输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。

那么输入过滤是否还有用吗？

答：还是有用的，对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。

但是并不是完全可靠，所以我们还需要通过其他方式来进行方法Xss攻击，也就是**通过要素2的预防，来进行防范**，这一部分可以分为一下两类：

1. 防止HTML中出现注入
2. 防止Js执行时，执行恶意代码

#### 预防存储型和反射型 XSS 攻击

存储型和反射型 XSS 都是**在服务端取出恶意代码后，插入到响应 HTML 里的**，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。

预防这两种漏洞，有两种常见做法：

1. 改成纯前端渲染，把代码和数据分隔开。

2. 对 HTML 做充分转义。

##### 纯前端渲染

渲染过程：

1. 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
2. 然后浏览器执行 HTML 中的 JavaScript。
3. JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。

> 有没有发现，这种纯前端的渲染方式，就和SPA单页面渲染一样，也就不能通过SSR\CSR\SSG这种静态渲染来处理了

在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（`.innerText`），还是属性（`.setAttribute`），还是样式（`.style`）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。

> 虽然纯前端渲染可以避免存储型XSS和反射型XSS攻击，但是还是无法避免DOM型XSS漏洞

在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。

##### 转义HTML

如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。

常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 `& < > " ' /` 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善：

| XSS 安全漏洞      | 简单转义是否有防护作用 |
| ----------------- | ---------------------- |
| HTML 标签文字内容 | 有                     |
| HTML 属性值       | 有                     |
| CSS 内联样式      | 无                     |
| 内联 JavaScript   | 无                     |
| 内联 JSON         | 无                     |
| 跳转链接          | 无                     |

所以要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。

HTML 的编码是十分复杂的，在不同的上下文里要使用相应的转义规则。

#### 预防 DOM 型 XSS 攻击

DOM 型 XSS 攻击，**实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了**。

在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()` 等。

如果用 Vue/React 技术栈，并且不使用 `v-html`/`dangerouslySetInnerHTML` 功能，就在前端 render 阶段避免 `innerHTML`、`outerHTML` 的 XSS 隐患。

DOM 中的内联事件监听器，如 `location`、`onclick`、`onerror`、`onload`、`onmouseover` 等，`<a>` 标签的 `href` 属性，JavaScript 的 `eval()`、`setTimeout()`、`setInterval()` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。

#### 其他防范措施

##### Content Security Policy

> 内容安全策略

严格的 CSP 在 XSS 的防范中可以起到以下的作用：

1. 禁止加载外域代码，防止复杂的攻击逻辑。

2. 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。

   > 上面两个都是基于同源侧滤

3. 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。

4. 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。

5. 合理使用上报可以及时发现 XSS，利于尽快修复问题。

##### 输出内容长度控制

对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。

##### 其他安全措施

1. HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。

2. 验证码：防止脚本冒充用户提交危险操作。

### 总结

1. XSS 防范是后端 RD 的责任，后端 RD 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。

   这个说法是不正确的，因为存储型XSS和反射型XSS是后端RD的责任，但是DOM型XSS攻击不发生在后端，是前端 RD 的责任。防范 XSS 是需要后端 RD 和前端 RD 共同参与的系统工程。敏感字符转义应该在输出 HTML 时进行，而不是在提交用户输入时。

2. 所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。

   这个说法也是不正确的，不同的上下文，如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致。 业务 RD 需要选取合适的转义库，并针对不同的上下文调用不同的转义规则。

虽然很难通过技术手段完全避免 XSS，但我们可以总结以下原则减少漏洞的产生：

- **利用模板引擎** 开启模板引擎自带的 HTML 转义功能。例如： 在 ejs 中，尽量使用 `<%= data %>` 而不是 `<%- data %>`； 在 doT.js 中，尽量使用 `{{! data }` 而不是 `{{= data }`； 在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 `freemarker.core.OutputFormat`。
- **避免内联事件** 尽量不要使用 `onLoad="onload('{{data}}')"`、`onClick="go('{{action}}')"` 这种拼接内联事件的写法。在 JavaScript 中通过 `.addEventlistener()` 事件绑定会更安全。
- **避免拼接 HTML** 前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 `createElement`、`setAttribute` 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。
- **时刻保持警惕** 在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。
- **增加攻击难度，降低攻击后果** 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。
- **主动检测和发现** 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。
