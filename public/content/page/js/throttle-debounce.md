### Thtottle and Debounce（节流与防抖）

| 文档创建人 | 创建日期   | 文档内容             | 更新时间   |
| ---------- | ---------- | -------------------- | ---------- |
| adsionli   | 2021-11-04 | 节流与防抖的知识学习 | 2021-11-04 |

## 节流和防抖

### 1. 什么是防抖(debounce)

比较官方的解释是：有一个等待时长，如果在这个等待时长内，再次调用了函数，就取消上一个定时器，并新建一个定时器。

> 比如说，设置一个时长为0-500ms的事件响应，在这500ms内，如果事件再次被触发，事件之前的回调就不会触发，从当前次触发的事件开始重新计时，直到有一个事件等待达到了500ms才会触发事件的回调。
>
> 其实有点像dnf里面的女武神开霸体护甲，霸体护甲持续的时间是不会被击倒、挑飞的，只有霸体护甲结束的时候才会被击倒、挑飞。这里的击倒和挑飞相当于回调，如果有人开G，永远处于霸体护甲的Buff下面，那就不会触发击倒、挑飞。就是这么个意思。

### 2. 什么是节流(throttle)

同样比较官方的解释是：有一个等待时长，每隔一段这个等待时长，函数必须执行一次。如果在这个等待时长内，当前延迟执行没有完成，它会忽略接下来调用该函数的请求，不会去取消上一个定时器。

> 这里就不比如说了，直接通俗解释：
>
> 这个开G的家伙，给了一点你能赢的曙光，虽然这个开G的可以一直保持霸体护甲的buff,但是在原则上的霸体护甲时间到的时候，还是会被击倒、挑飞的，所以你就得抓住这个时间点，一套带走他。

### 3. 防抖和节流之间的不同点

防抖在等待时长的时候如果有一个事件进来了，就取消上一次的定时器，创建一个新的定时器。但是节流却不会，它会忽略这些在等待时长中的请求，直到时间走完并执行回调，如果这时候又下一次事件进入，就在开始创建新的计时器。

### 4. 防抖与节流的适用事件

1. `debounce`主要用于适用于 `input`, `keyup`, `keydown` 等事件, 亦或者 `click` 事件需要防止用户在某个时间范围内多次点击的时候，也可以用。
2. `throttle` 适用于 `scroll`, `mousemove` 等事件。因为`scroll`或是`mousemove`出发都是十分频繁的，一旦出现一点变化都会立马执行回调，所以节流会更加适合

> 通过上述的分析，我自己本身得出了一个可能不是最正确的结论：
>
> 防抖就是一个设置了最大时长的节流。
>
> 虽然不知道对不对，但是我感觉很有道理。分析起来也很简单，防抖直到最后一次符合等待时长的才会执行回调，那么设置防抖的事件开始到事件回调执行的时长给节流，不就很类似了嘛，我觉得是这样，还望大家指正，可以发邮件给我：adsionli@foxmail.com，大家共同进步。

## 节流和防抖的代码实现

### 节流的实现

> 主要参考的文章来自于:[节流代码实现参考](https://juejin.cn/post/6959116301285457928)

1. 定时器版本实现

   ```js
   function throttle(func, time){
       let timer = null;
       return function(...args){
           if(!timer){
           	timer = setTimeout(() => {
                   func.apply(this, args);
                   timer = null;
               }, time)   
           }
       }
   }
   ```

   > 解释一下这段代码：
   >
   > 1. 首先可以看到这段代码的返回是一个function函数，也就是使用了柯里化，具体什么是柯里化以及柯里化的好处这里就不说了，可以看这篇文章[柯里化的介绍](/#/page/js/currying)
   > 2. 这里的`timer`一开始设置为null，就相当于起了一个锁的作用，如果说当前次`setTimeout`执行完毕之后，timer就会变成null，这个时候下一次事件进来之后就可以创建一个`timer`，达到节流的目的了。
   > 3. 这里有一个结构的传参，主要是不知道会传入多少参数，比如event事件的传参的话，基本只有一个event类，说一这里为了保险起见，直接设置为结构变量。
   > 4. 通过apply将作用域及传入参数绑定到回调方法中，方便回调方法使用。

2. 时间戳版本实现

   ```js
   function throttle(func, timer){
       let start = 0;
       return function(...args){
           //Date类的一种转换成时间戳的快速写法
           let now = +new Date();
           if(now - start > timer){
              	func.apply(this, args);
               start = now;
           }
       }
   }
   ```

   > 代码解释：
   >
   > 1. 首先我们对start标记变量初始化的值为0，这就意味着当事件第一次进入时，就马上执行一次。等到第一次执行完成后，又会变为隔timer执行一次。
   > 2. 为什么初始为0，因为如果不为0，那么在第一次触发事件回调中的判断时，会出现问题，这个时候`now`通过`Date`类返回的时间戳会和`start`申明时的时间戳大小完全相同，进不入if中，导致后续的事件都无法进行处理了，所以在初始化的时候要设置值为0，保证第一次的顺利触发。
   > 3. if中的判断就是关键了，*大于就证明已经过了规定时间，可以再次调用函数，否则反之*

   3. 两者之间的不同

      定时器版本会在事件执行到最后一次的时候一定会被调用，而定时器版本会在第一次执行立即调用。

      > 定时器版本最后一次立即调用是因为在最后一次的时候，事件的上一次进入之后，会在最后一次停下的时候被触发，感觉就像是最后一次一定会被执行。

      定时器也可以是第一次立即执行，稍微调整一下代码就可以了

      ```js
      function throttle(func, timer){
          let time = null;
          return function(...args){
              func.apply(this, args);
              if(!time){
                 time = setTimeout(() => {
                     time = null;
                 }, timer)
              }
          }
      }
      ```

   4. 面试中会遇到的问题：第一次先执行，最后一次一定被执行，中间使用节流

      这个其实在上面定时器版本的改写就可以实现。

      下面还有一种写法，在这里记录一下

      ```js
      function throttleFirstEnd(func, timer) {
          let start = 0;
          let time = null;
          return function(...args){
              let now = +new Date();
              //这里先判断一下是否是在一次执行之内，如果是进入定时器分支，如果不是进入时间戳分支
              if (now - start < timer){
                  time && clearTimeout(time);
                  //这里就会一直被覆盖掉，但是在最后一次时，一定会确保这个time的回调可以执行
                  time = setTimeout(() => {
                      start = now;
                      func.apply(this, args)
                  }, timer);
              }else {
                  //这里是主要实现中间部分与第一次节流
                  start = now;
                  func.apply(this, args);
              }
          }
      }
      ```

      > 其实仔细看一下上面的这段代码，会发现，定时器的处理和防抖的代码是一样的，为了确保最后一次的顺利执行，我们只需要为时间戳的实现方式添加最后一次的定时器功能就行。这个定时器，就又和我上面总结过的一句话很像,==防抖就是一个设置了最大时长的节流。==

### 防抖的代码实现

> 主要参考文章来自于:[防抖的代码实现](https://juejin.cn/post/6951594100848066574)

防抖的实现比较简单了，因为可以直接覆盖掉之前的，所以每次只要清除一下上次的定时器就可以了。

```js
function debounce(func,delay) {  
    let timer=null
    return function (...args) {  
        if(timer) clearTimeout(timer) //先判断是否有上一次留下的定时器，有就删除，防止影响当前要执行的定时器
        timer=setTimeout(()=>{
            func.apply(this,args)
        },delay)
    }
}
```

## 节流和防抖的使用场景(个人见解)

1. 节流

   > 1. 基于滚动条的图片懒加载的实现。
   > 2. mousemove事件的捕获。
   > 3. 商城秒杀的处理，可以使用节流的形式来处理秒杀按钮的点击事件。
   > 4. 用户改变平台窗口大小的时候，执行相应改变的时候，可以添加节流。
   > 5. 监听滚动事件，比如是否滑到底部自动加载更多。
   > 6. 等等......（遇到之后会进行补充）

2. 防抖

   > 1. select远程搜索框的实现，可以加入防抖，直到最后一次输入结束触发搜索，减少请求的开支
   >
   > 2. 用户反复提交按钮请求的时候，可以使用防抖。
   > 3. 用户通过键盘输入事件的获取，可以使用防抖，keyup,keydown事件。
   > 4. form表单的提交，加入防抖，确保表单不会重复提交。
   > 5. 等等......（遇到了之后会进行补充）

## 内容的总结

节流和防抖的功能实现是类似的，但是其最终的效果是不同的，防抖是某一段时间内只执行一次，而节流是间隔时间执行。他们都可以防止某一时间内频繁的触发，但是也要根据具体场景具体分析，合理利用两者的不同来进行业务开发。

> 果然，节流与防抖的功能真的很棒，实现的方式也是十分的简单和巧妙。大大提交用户交互过程的使用体验同时减少不必要的性能开支。节流与防抖的知识不应该只停留在八股文之中，还应该在实际生产开发中去使用。

